<?xml version="1.0" encoding="UTF-8"?>
<section name="Workbench">
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog">
		<item key="selection" value="PFP */"/>
		<item key="wrap" value="true"/>
		<item key="casesensitive" value="false"/>
		<item key="wholeword" value="false"/>
		<item key="incremental" value="false"/>
		<item key="isRegEx" value="false"/>
		<list key="findhistory">
			<item value="PFP */"/>
			<item value="/* USER CODE BEGIN Header */&#x0A;/**&#x0A;  ******************************************************************************&#x0A;  * @file           : main.c&#x0A;  * @brief          : Main program body&#x0A;  ******************************************************************************&#x0A;  * @attention&#x0A;  *&#x0A;  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2020 STMicroelectronics.&#x0A;  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;&#x0A;  *&#x0A;  * This software component is licensed by ST under BSD 3-Clause license,&#x0A;  * the &quot;License&quot;; You may not use this file except in compliance with the&#x0A;  * License. You may obtain a copy of the License at:&#x0A;  *                        opensource.org/licenses/BSD-3-Clause&#x0A;  *&#x0A;  ******************************************************************************&#x0A;  */&#x0A;/* USER CODE END Header */&#x0A;&#x0A;/* Includes ------------------------------------------------------------------*/&#x0A;#include &quot;main.h&quot;&#x0A;&#x0A;/* Private includes ----------------------------------------------------------*/&#x0A;/* USER CODE BEGIN Includes */&#x0A;&#x0A;/* USER CODE END Includes */&#x0A;&#x0A;/* Private typedef -----------------------------------------------------------*/&#x0A;/* USER CODE BEGIN PTD */&#x0A;&#x0A;/* USER CODE END PTD */&#x0A;&#x0A;/* Private define ------------------------------------------------------------*/&#x0A;/* USER CODE BEGIN PD */&#x0A;/* USER CODE END PD */&#x0A;&#x0A;/* Private macro -------------------------------------------------------------*/&#x0A;/* USER CODE BEGIN PM */&#x0A;&#x0A;/* USER CODE END PM */&#x0A;&#x0A;/* Private variables ---------------------------------------------------------*/&#x0A;SPI_HandleTypeDef hspi1;&#x0A;DMA_HandleTypeDef hdma_spi1_tx;&#x0A;DMA_HandleTypeDef hdma_spi1_rx;&#x0A;&#x0A;TIM_HandleTypeDef htim10;&#x0A;&#x0A;UART_HandleTypeDef huart2;&#x0A;&#x0A;/* USER CODE BEGIN PV */&#x0A;&#x0A;volatile GPIO_PinState disp_state [4][8];&#x0A;&#x0A;const uint16_t tx_buffer [3] = {0xA900,   //nonincremental reading buffer 10 1001&#x0A;                                0xAB00,   //nonincremental reading buffer 10 1011&#x0A;                                0xAD00};  //nonincremental reading buffer 10 1101&#x0A;&#x0A;volatile uint16_t rx_buffer [3];&#x0A;&#x0A;&#x0A;/* USER CODE END PV */&#x0A;&#x0A;/* Private function prototypes -----------------------------------------------*/&#x0A;void SystemClock_Config(void);&#x0A;static void MX_GPIO_Init(void);&#x0A;static void MX_DMA_Init(void);&#x0A;static void MX_SPI1_Init(void);&#x0A;static void MX_TIM10_Init(void);&#x0A;static void MX_USART2_UART_Init(void);&#x0A;/* USER CODE BEGIN PFP */&#x0A;&#x0A;/* USER CODE END PFP */&#x0A;&#x0A;/* Private user code ---------------------------------------------------------*/&#x0A;/* USER CODE BEGIN 0 */&#x0A;&#x0A;/* USER CODE END 0 */&#x0A;&#x0A;/**&#x0A;  * @brief  The application entry point.&#x0A;  * @retval int&#x0A;  */&#x0A;int main(void)&#x0A;{&#x0A;  /* USER CODE BEGIN 1 */&#x0A;&#x09;char data[10];&#x0A;&#x09;int size;&#x0A;&#x09;uint16_t send = 0xA900;&#x0A;&#x09;uint16_t receive;&#x0A;&#x0A;  /* USER CODE END 1 */&#x0A;&#x0A;  /* MCU Configuration--------------------------------------------------------*/&#x0A;&#x0A;  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */&#x0A;  HAL_Init();&#x0A;&#x0A;  /* USER CODE BEGIN Init */&#x0A;&#x0A;  /* USER CODE END Init */&#x0A;&#x0A;  /* Configure the system clock */&#x0A;  SystemClock_Config();&#x0A;&#x0A;  /* USER CODE BEGIN SysInit */&#x0A;&#x0A;  /* USER CODE END SysInit */&#x0A;&#x0A;  /* Initialize all configured peripherals */&#x0A;  MX_GPIO_Init();&#x0A;  MX_DMA_Init();&#x0A;  MX_SPI1_Init();&#x0A;  MX_TIM10_Init();&#x0A;  MX_USART2_UART_Init();&#x0A;  /* USER CODE BEGIN 2 */&#x0A;  //HAL_TIM_Base_Start_IT(&amp;htim10);&#x0A;&#x0A;  // TODO spi peripherial init&#x0A;&#x0A;  disp_buffer_update(0,1);&#x0A;  disp_buffer_update(1,2);&#x0A;  disp_buffer_update(2,3);&#x0A;  disp_buffer_update(3,4);&#x0A;  __HAL_SPI_ENABLE(&amp;hspi1);&#x0A;//&#x0A;  /* USER CODE END 2 */&#x0A;&#x0A;  /* Infinite loop */&#x0A;  /* USER CODE BEGIN WHILE */&#x0A;  while (1)&#x0A;  {&#x0A;    /* USER CODE END WHILE */&#x0A;&#x0A;    /* USER CODE BEGIN 3 */&#x0A;&#x09;  //HAL_SPI_TransmitReceive(&amp;hspi1, send, receive, 1, 1000);&#x0A;&#x09;  size = sprintf(data, &quot;Hello\n&quot;);&#x0A;&#x09;  HAL_UART_Transmit_IT(&amp;huart2, data, size);&#x0A;  }&#x0A;  /* USER CODE END 3 */&#x0A;}&#x0A;&#x0A;/**&#x0A;  * @brief System Clock Configuration&#x0A;  * @retval None&#x0A;  */&#x0A;void SystemClock_Config(void)&#x0A;{&#x0A;  RCC_OscInitTypeDef RCC_OscInitStruct = {0};&#x0A;  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};&#x0A;&#x0A;  /** Configure the main internal regulator output voltage &#x0A;  */&#x0A;  __HAL_RCC_PWR_CLK_ENABLE();&#x0A;  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);&#x0A;  /** Initializes the CPU, AHB and APB busses clocks &#x0A;  */&#x0A;  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;&#x0A;  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;&#x0A;  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;&#x0A;  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;&#x0A;  RCC_OscInitStruct.PLL.PLLM = 4;&#x0A;  RCC_OscInitStruct.PLL.PLLN = 100;&#x0A;  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;&#x0A;  RCC_OscInitStruct.PLL.PLLQ = 4;&#x0A;  if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)&#x0A;  {&#x0A;    Error_Handler();&#x0A;  }&#x0A;  /** Initializes the CPU, AHB and APB busses clocks &#x0A;  */&#x0A;  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK&#x0A;                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;&#x0A;  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;&#x0A;  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;&#x0A;  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;&#x0A;  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;&#x0A;&#x0A;  if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)&#x0A;  {&#x0A;    Error_Handler();&#x0A;  }&#x0A;}&#x0A;&#x0A;/**&#x0A;  * @brief SPI1 Initialization Function&#x0A;  * @param None&#x0A;  * @retval None&#x0A;  */&#x0A;static void MX_SPI1_Init(void)&#x0A;{&#x0A;&#x0A;  /* USER CODE BEGIN SPI1_Init 0 */&#x0A;&#x0A;  /* USER CODE END SPI1_Init 0 */&#x0A;&#x0A;  /* USER CODE BEGIN SPI1_Init 1 */&#x0A;&#x0A;  /* USER CODE END SPI1_Init 1 */&#x0A;  /* SPI1 parameter configuration*/&#x0A;  hspi1.Instance = SPI1;&#x0A;  hspi1.Init.Mode = SPI_MODE_MASTER;&#x0A;  hspi1.Init.Direction = SPI_DIRECTION_2LINES;&#x0A;  hspi1.Init.DataSize = SPI_DATASIZE_16BIT;&#x0A;  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;&#x0A;  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;&#x0A;  hspi1.Init.NSS = SPI_NSS_HARD_OUTPUT;&#x0A;  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;&#x0A;  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;&#x0A;  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;&#x0A;  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;&#x0A;  hspi1.Init.CRCPolynomial = 10;&#x0A;  if (HAL_SPI_Init(&amp;hspi1) != HAL_OK)&#x0A;  {&#x0A;    Error_Handler();&#x0A;  }&#x0A;  /* USER CODE BEGIN SPI1_Init 2 */&#x0A;&#x0A;  /* USER CODE END SPI1_Init 2 */&#x0A;&#x0A;}&#x0A;&#x0A;/**&#x0A;  * @brief TIM10 Initialization Function&#x0A;  * @param None&#x0A;  * @retval None&#x0A;  */&#x0A;static void MX_TIM10_Init(void)&#x0A;{&#x0A;&#x0A;  /* USER CODE BEGIN TIM10_Init 0 */&#x0A;&#x0A;  /* USER CODE END TIM10_Init 0 */&#x0A;&#x0A;  /* USER CODE BEGIN TIM10_Init 1 */&#x0A;&#x0A;  /* USER CODE END TIM10_Init 1 */&#x0A;  htim10.Instance = TIM10;&#x0A;  htim10.Init.Prescaler = 0;&#x0A;  htim10.Init.CounterMode = TIM_COUNTERMODE_UP;&#x0A;  htim10.Init.Period = 9999;&#x0A;  htim10.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;&#x0A;  htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;&#x0A;  if (HAL_TIM_Base_Init(&amp;htim10) != HAL_OK)&#x0A;  {&#x0A;    Error_Handler();&#x0A;  }&#x0A;  /* USER CODE BEGIN TIM10_Init 2 */&#x0A;&#x0A;  /* USER CODE END TIM10_Init 2 */&#x0A;&#x0A;}&#x0A;&#x0A;/**&#x0A;  * @brief USART2 Initialization Function&#x0A;  * @param None&#x0A;  * @retval None&#x0A;  */&#x0A;static void MX_USART2_UART_Init(void)&#x0A;{&#x0A;&#x0A;  /* USER CODE BEGIN USART2_Init 0 */&#x0A;&#x0A;  /* USER CODE END USART2_Init 0 */&#x0A;&#x0A;  /* USER CODE BEGIN USART2_Init 1 */&#x0A;&#x0A;  /* USER CODE END USART2_Init 1 */&#x0A;  huart2.Instance = USART2;&#x0A;  huart2.Init.BaudRate = 115200;&#x0A;  huart2.Init.WordLength = UART_WORDLENGTH_8B;&#x0A;  huart2.Init.StopBits = UART_STOPBITS_1;&#x0A;  huart2.Init.Parity = UART_PARITY_NONE;&#x0A;  huart2.Init.Mode = UART_MODE_TX_RX;&#x0A;  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;&#x0A;  huart2.Init.OverSampling = UART_OVERSAMPLING_16;&#x0A;  if (HAL_UART_Init(&amp;huart2) != HAL_OK)&#x0A;  {&#x0A;    Error_Handler();&#x0A;  }&#x0A;  /* USER CODE BEGIN USART2_Init 2 */&#x0A;&#x0A;  /* USER CODE END USART2_Init 2 */&#x0A;&#x0A;}&#x0A;&#x0A;/** &#x0A;  * Enable DMA controller clock&#x0A;  */&#x0A;static void MX_DMA_Init(void) &#x0A;{&#x0A;&#x0A;  /* DMA controller clock enable */&#x0A;  __HAL_RCC_DMA2_CLK_ENABLE();&#x0A;&#x0A;  /* DMA interrupt init */&#x0A;  /* DMA2_Stream0_IRQn interrupt configuration */&#x0A;  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);&#x0A;  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);&#x0A;  /* DMA2_Stream2_IRQn interrupt configuration */&#x0A;  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);&#x0A;  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);&#x0A;&#x0A;}&#x0A;&#x0A;/**&#x0A;  * @brief GPIO Initialization Function&#x0A;  * @param None&#x0A;  * @retval None&#x0A;  */&#x0A;static void MX_GPIO_Init(void)&#x0A;{&#x0A;  GPIO_InitTypeDef GPIO_InitStruct = {0};&#x0A;&#x0A;  /* GPIO Ports Clock Enable */&#x0A;  __HAL_RCC_GPIOC_CLK_ENABLE();&#x0A;  __HAL_RCC_GPIOH_CLK_ENABLE();&#x0A;  __HAL_RCC_GPIOA_CLK_ENABLE();&#x0A;  __HAL_RCC_GPIOB_CLK_ENABLE();&#x0A;&#x0A;  /*Configure GPIO pin Output Level */&#x0A;  HAL_GPIO_WritePin(GPIOC, disp_G_Pin|disp_D_Pin|disp_E_Pin|disp_C_Pin &#x0A;                          |disp_B_Pin|disp_F_Pin|disp_A_Pin|disp_DP_Pin &#x0A;                          |disp_COM4_Pin|disp_COM3_Pin|disp_COM2_Pin|disp_COM1_Pin, GPIO_PIN_RESET);&#x0A;&#x0A;  /*Configure GPIO pin Output Level */&#x0A;  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);&#x0A;&#x0A;  /*Configure GPIO pin : B1_Pin */&#x0A;  GPIO_InitStruct.Pin = B1_Pin;&#x0A;  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;&#x0A;  GPIO_InitStruct.Pull = GPIO_NOPULL;&#x0A;  HAL_GPIO_Init(B1_GPIO_Port, &amp;GPIO_InitStruct);&#x0A;&#x0A;  /*Configure GPIO pins : disp_G_Pin disp_D_Pin disp_E_Pin disp_C_Pin &#x0A;                           disp_B_Pin disp_F_Pin disp_A_Pin disp_DP_Pin &#x0A;                           disp_COM4_Pin disp_COM3_Pin disp_COM2_Pin disp_COM1_Pin */&#x0A;  GPIO_InitStruct.Pin = disp_G_Pin|disp_D_Pin|disp_E_Pin|disp_C_Pin &#x0A;                          |disp_B_Pin|disp_F_Pin|disp_A_Pin|disp_DP_Pin &#x0A;                          |disp_COM4_Pin|disp_COM3_Pin|disp_COM2_Pin|disp_COM1_Pin;&#x0A;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;&#x0A;  GPIO_InitStruct.Pull = GPIO_NOPULL;&#x0A;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;&#x0A;  HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);&#x0A;&#x0A;  /*Configure GPIO pin : LD2_Pin */&#x0A;  GPIO_InitStruct.Pin = LD2_Pin;&#x0A;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;&#x0A;  GPIO_InitStruct.Pull = GPIO_NOPULL;&#x0A;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;&#x0A;  HAL_GPIO_Init(LD2_GPIO_Port, &amp;GPIO_InitStruct);&#x0A;&#x0A;  /*Configure GPIO pin : button_1_Pin */&#x0A;  GPIO_InitStruct.Pin = button_1_Pin;&#x0A;  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;&#x0A;  GPIO_InitStruct.Pull = GPIO_NOPULL;&#x0A;  HAL_GPIO_Init(button_1_GPIO_Port, &amp;GPIO_InitStruct);&#x0A;&#x0A;  /*Configure GPIO pin : PA15 */&#x0A;  GPIO_InitStruct.Pin = GPIO_PIN_15;&#x0A;  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;&#x0A;  GPIO_InitStruct.Pull = GPIO_NOPULL;&#x0A;  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#x0A;&#x0A;}&#x0A;&#x0A;/* USER CODE BEGIN 4 */&#x0A;&#x0A;/* USER CODE END 4 */&#x0A;&#x0A;/**&#x0A;  * @brief  This function is executed in case of error occurrence.&#x0A;  * @retval None&#x0A;  */&#x0A;void Error_Handler(void)&#x0A;{&#x0A;  /* USER CODE BEGIN Error_Handler_Debug */&#x0A;  /* User can add his own implementation to report the HAL error return state */&#x0A;&#x0A;  /* USER CODE END Error_Handler_Debug */&#x0A;}&#x0A;&#x0A;#ifdef  USE_FULL_ASSERT&#x0A;/**&#x0A;  * @brief  Reports the name of the source file and the source line number&#x0A;  *         where the assert_param error has occurred.&#x0A;  * @param  file: pointer to the source file name&#x0A;  * @param  line: assert_param error line source number&#x0A;  * @retval None&#x0A;  */&#x0A;void assert_failed(uint8_t *file, uint32_t line)&#x0A;{ &#x0A;  /* USER CODE BEGIN 6 */&#x0A;  /* User can add his own implementation to report the file name and line number,&#x0A;     tex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */&#x0A;  /* USER CODE END 6 */&#x0A;}&#x0A;#endif /* USE_FULL_ASSERT */&#x0A;&#x0A;/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/&#x0A;"/>
			<item value="TIM10"/>
			<item value="TIM_10"/>
		</list>
		<list key="replacehistory">
		</list>
	</section>
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog_dialogBounds">
		<item key="DIALOG_X_ORIGIN" value="911"/>
		<item key="DIALOG_Y_ORIGIN" value="128"/>
		<item key="DIALOG_WIDTH" value="342"/>
		<item key="DIALOG_HEIGHT" value="445"/>
		<item key="DIALOG_FONT_NAME" value="1|Ubuntu|11.0|0|GTK|1|"/>
	</section>
</section>
